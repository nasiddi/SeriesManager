<template>
  <div>
    <div
      v-if="!job"
      key="loading"
      class="mt-5 mb-5 d-flex justify-content-center"
    >

      <font-awesome-icon
        icon="circle-notch"
        scale="3"
        spin/>
    </div>
    <div
      v-else
      key="loading">
      <h1>
        Evaluate {{ job ? job.friendly_name : 'Job' }}

        <span class="float-right">
          <b-button-group class="cursor-pointer">
            <b-dropdown
              right
              text="Tools"
              variant="outline-primary"
            >
              <b-dropdown-item :to="{ name: 'monitor.job', params: { jobId: jobId } }">
                Monitor this job
              </b-dropdown-item>
              <span v-if="_.size(projects) > 0">
                <b-dropdown-divider/>
                <b-dropdown-header>Corpus Analysis</b-dropdown-header>
                <b-dropdown-item
                  v-for="project in projects"
                  :key="project.uuid"
                  :to="{ name: 'corpus.project', params: { project_uuid: project.uuid} }">
                  {{ project.friendly_name }}
                </b-dropdown-item>
              </span>
            </b-dropdown>
          </b-button-group>
        </span>
      </h1>

      <p>
        Here you can evaluate models generated by a job. An evaluation conists of:
      </p>

      <ol>
        <li>A set of models you'd like to use for the evaluation</li>
        <li>Input data</li>
      </ol>

      <b-form @submit.prevent="submit">

        <b-card
          :border-variant="card1Variant"
          class="m-4"
        >
          <h4 slot="header">Models</h4>
          <div class="clearfix">
            <p class="float-left">Against which models would you like to run your input?</p>

            <b-button-toolbar class="float-right">
              <b-button-group
                size="sm"
                class="mx-1"
              >
                <b-button
                  :pressed="allProcessesChecked"
                  variant="outline-secondary"
                  @click="checkAllProcesses"
                >All models</b-button>
                <b-button
                  :pressed="noProcessesChecked"
                  variant="outline-secondary"
                  @click="uncheckAllProcesses"
                >No models</b-button>
              </b-button-group>
              <b-button-group
                size="sm"
                class="mx-1"
              >
                <b-button
                  :pressed="onlyBestProcessChecked"
                  variant="outline-secondary"
                  @click="checkBestProcess"
                >Best model only</b-button>
              </b-button-group>
            </b-button-toolbar>
          </div>

          <b-list-group>
            <b-list-group-item
              v-for="proc in processes"
              :key="proc.id"
            >
              <b-row>
                <b-col cols="1">
                  <b-form-checkbox v-model="processesChecked[proc.job_proc]"/>
                </b-col>
                <b-col>{{ proc.friendly_name }}</b-col>
                <b-col cols="2">
                  <!-- eslint-disable max-len -->
                  <span
                    v-b-popover.hover.auto="`Since we always save the highest-scoring model, this F1 score refers to the highest score this process has achieved in any epoch.`"
                    v-if="proc.f1_score_max"
                    title="Max score"
                  >
                    <!-- eslint-enable max-len -->
                    <small>F1 score:</small>
                    <b-badge :variant="proc.process_status.bs_variant">
                      {{ f1ScoreFormatted(proc.f1_score_max) }}
                    </b-badge>
                  </span>
                </b-col>
              </b-row>
            </b-list-group-item>
          </b-list-group>
        </b-card>

        <b-card
          :border-variant="card2Variant"
          class="m-4"
        >
          <h4 slot="header">Input</h4>
          <p>
            What would you like to feed as input to the computed models?
            You can provide a single string <em>or</em> a file.
          </p>

          <b-form-group label="Choose your type of input">
            <b-form-radio-group
              v-model="inputType"
              :options="inputTypes"
              buttons
              button-variant="outline-primary"/>
          </b-form-group>


          <b-row v-if="inputType === 'single'">
            <b-col>
              <b-form-group
                horizontal
                label="Enter a string">
                <b-form-input
                  v-model="inputs.single"
                  :state="Boolean(inputs.single)"/>
              </b-form-group>
            </b-col>
          </b-row>

          <div v-if="inputType === 'data'">
            <b-row>
              <b-col>
                <b-form-group
                  horizontal
                  label="File">
                  <b-form-select
                    v-model="inputs.data"
                    :options="files"
                    :state="Boolean(inputs.data)"/>
                </b-form-group>
              </b-col>
            </b-row>
          </div>

        </b-card>

        <b-button
          :variant="submitVariant"
          :disabled="!submittable"
          type="submit"
          size="lg"
          block
        >
          <span v-if="submittable">Evaluate</span>
          <span v-if="!submittable && !evaluationRunning">Some required fields are empty.</span>
          <span v-if="evaluationRunning">Evaluating <font-awesome-icon
            icon="circle-notch"
            spin/></span>
        </b-button>
      </b-form>
      <p v-if="_.size(evaluationsExposed) > 0">
        <small>
          Please note: evaluations are not saved and their results will be discarded
          when you close this browser tab or navigate to a different page.
        </small>
      </p>
      <b-card
        v-for="(ev, i) in evaluationsExposed"
        :key="ev.id"
        class="m-4"
      >
        <div slot="header">
          <h4
            v-if="ev.input.type==='text'"
            class="float-left">
            Results for <code>{{ ev.input.value }}</code>
          </h4>
          <h4
            v-if="ev.input.type==='file'"
            class="float-left">
            Results for <code>{{ getFile(ev.input.value).friendly_name }}</code>
          </h4>
          <b-badge
            pill
            variant="dark"
            class="float-right"
          >#{{ evaluationsExposed.length - i }}</b-badge>
        </div>
        <div>
          <classifier-comparison
            v-if="evaluationComparisons[ev.id]"
            :classifier-comparison="evaluationComparisons[ev.id]"
            :processes="ev.processes"
            :uuid="job.uuid"
            endpoint="evaluate"
          />
          <p v-if="!evaluationComparisons[ev.id] && ev.input.type==='file'">
            <small><em>{{ ev.comparisonText }}</em></small>
          </p>
          <b-list-group>
            <b-list-group-item
              v-for="proc in ev.processes"
              :key="proc.id"
            >
              <b-row>
                <b-col><h5>{{ proc.friendly_name }}</h5></b-col>
                <b-col class="text-right">
                  <div
                    v-if="ev.results[proc.id] && ev.results[proc.id].status === 'done'"
                    key="loading-evaluation-result">
                    <b-badge
                      v-if="ev.results[proc.id].label"
                      :variant="color(ev.results[proc.id].label)">
                      {{ ev.results[proc.id].label }}
                    </b-badge>
                    <b-button
                      v-if="ev.results[proc.id].download"
                      :href="`${$globalData.rootUrl}evaluate/${ev.id}/${proc.id}/download`"
                      size="sm"
                      variant="outline-info"
                    >
                      <font-awesome-icon icon="download"/> Download
                    </b-button>
                  </div>
                  <font-awesome-icon
                    v-else
                    key="loading-evaluation-result"
                    icon="circle-notch"
                    spin/>
                </b-col>
              </b-row>
              <b-row
                v-if="_.isObject(ev.results[proc.id]) && _.size(ev.results[proc.id].extraData) > 0"
              >
                <b-col v-if="_.size(ev.results[proc.id].extraData.confusion_matrix) > 0">
                  <h6>Confusion Matrix</h6>
                  <confusion-matrix
                    :data="ev.results[proc.id].extraData.confusion_matrix"/>
                </b-col>
                <b-col v-if="_.size(ev.results[proc.id].extraData.classification_report) > 0">
                  <h6>Classification Report</h6>
                  <classification-report
                    :data="ev.results[proc.id].extraData.classification_report"/>
                </b-col>
              </b-row>
            </b-list-group-item>
          </b-list-group>
        </div>
      </b-card>

    </div>
  </div>
</template>


<script>
import ConfusionMatrix from '@/components/Monitor/Processes/ConfusionMatrix';
import ClassifierComparison from '@/components/Monitor/ClassifierComparison';
import ClassificationReport from '@/components/Monitor/Processes/ClassificationReport';

const _ = require('lodash');
const uuidv1 = require('uuid/v1');

export default {
  components: { ConfusionMatrix, ClassificationReport, ClassifierComparison },
  data: () => ({
    refreshTimeout: 750,
    httpTimeout: 3000,
    httpTimeoutEvaluation: 60000,
    jobId: null,
    job: null,
    processes: null,
    processesChecked: {},
    evaluationRunning: false,
    evaluationComplete: false,
    evaluations: [],
    evaluationComparisons: {},
    files: [],
    projects: [],
    inputType: 'single',
    inputTypes: [],
    inputs: {
      single: null,
      test: null,
      data: null,
    },
  }),
  computed: {
    inputValue() {
      if (this.inputType === 'single') return this.inputs.single;
      if (this.inputType === 'data') return this.inputs.data;
      if (this.inputType === 'test') return this.inputs.test;
      return false;
    },
    evaluationsExposed() {
      return _.chain(this.evaluations)
        .sortBy(['timestamp'])
        .reverse()
        .value();
    },
    bestProcess() {
      return _.chain(this.processes)
        .sortBy(['f1_score_max'])
        .last()
        .value();
    },
    allProcessesChecked() {
      return (
        _.chain(this.processesChecked)
          .filter(pc => pc)
          .size()
          .value() === _.size(this.processesChecked)
      );
    },
    noProcessesChecked() {
      return (
        _.chain(this.processesChecked)
          .filter(pc => pc)
          .size()
          .value() === 0
      );
    },
    onlyBestProcessChecked() {
      return (
        _.chain(this.processesChecked)
          .filter(pc => pc)
          .size()
          .value() === 1 && this.processesChecked[this.bestProcess.job_proc]
      );
    },
    checkedProcesses() {
      return _.filter(this.processes, proc => this.processesChecked[proc.job_proc]);
    },
    submittable() {
      return this.card1Check && this.card2Check && !this.evaluationRunning;
    },
    card1Check() {
      return _.reduce(this.processesChecked, (count, el) => (el ? count + 1 : count), 0) > 0;
    },
    card2Check() {
      return (
        (this.inputType === 'single' && this.inputs.single)
        || (this.inputType === 'test' && this.inputs.test)
        || (this.inputType === 'data' && this.inputs.data)
      );
    },
    card1Variant() {
      return this.card1Check ? 'success' : 'danger';
    },
    card2Variant() {
      return this.card2Check ? 'success' : 'danger';
    },
    submitVariant() {
      if (this.evaluationRunning) {
        return 'info';
      }
      if (this.evaluationComplete) {
        return 'success';
      }
      if (!this.submittable) {
        return 'warning';
      } if (this.submittable) {
        return 'primary';
      }

      return 'default';
    },
  },
  metaInfo() {
    return {
      title: `Evaluate ${this.job ? this.job.friendly_name : this.jobId}`,
    };
  },
  created() {
    this.jobId = this.$route.params.job_uuid;
  },
  mounted() {
    this.refresh();
  },
  methods: {
    getFile(uuid) {
      return _.chain(this.files)
        .filter(f => f.value === uuid)
        .map(f => f.extra)
        .first()
        .value();
    },
    submit() {
      this.evaluationRunning = true;

      const evalId = uuidv1();

      const evaluation = {
        id: evalId,
        comparisonText:
          'The classifier comparison will be performed once all models have evaluated the input.',
        timestamp: Date.now(),
        input: {
          type: this.inputType === 'single' ? 'text' : 'file',
          value: this.inputValue,
        },
        results: _.chain(this.checkedProcesses)
          .mapKeys(proc => proc.id)
          .mapValues(() => null)
          .value(),
        processes: _.values(this.checkedProcesses),
      };

      const key = this.evaluations.push(evaluation) - 1;
      _.chain(evaluation.results)
        .keys()
        .each((pid) => {
          this.$http.post(`evaluate/${evalId}/${pid}`, evaluation.input, {
            timeout: this.httpTimeoutEvaluation,
          });
          this.refreshEvaluationResult(evalId, pid, key);
        })
        .value();

      this.evaluationComplete = true;
      this.evaluationRunning = false;
    },
    refresh() {
      this.$http.get(`jobs/${this.$router.currentRoute.params.job_uuid}/projects`).then((res) => {
        this.projects = res.body;
      });

      this.$http.get(`jobs/${this.jobId}`, { timeout: this.httpTimeout }).then((response) => {
        this.job = response.body;
        this.inputTypes = [
          { text: 'A single string', value: 'single' },
          { text: 'Another file', value: 'data' },
        ];
        if (this.job.file_id_test) {
          this.inputTypes.push({
            text: 'The test file you provided for this job',
            value: 'test',
          });
        }

        this.$http.get('files/').then((res) => {
          const formatfileSelect = f => ({
            text: `${f.friendly_name} (${f.uuid})`,
            value: f.uuid,
            extra: f,
          });

          this.files = _.chain(res.body)
            .filter(f => f.is_parsed === 1)
            .map(formatfileSelect)
            .sortBy(f => f.text.toLowerCase())
            .value();

          this.inputs.data = _.chain(this.files)
            .filter(f => !f.disabled)
            .map(f => f.value)
            .first()
            .value();
          if (this.job.file_test) {
            this.inputs.test = this.job.file_test.uuid;
          }
        });
      });

      this.$http
        .get(`jobs/${this.jobId}/processes`, { timeout: this.httpTimeout })
        .then((response) => {
          this.processes = _.filter(
            response.body,
            proc => proc.process_status.name === 'completed'
              || (proc.details_json && proc.details_json.has_epochs),
          );
          this.processesChecked = _.mapKeys(this.processes, proc => proc.job_proc);
          this.checkAllProcesses();
        });
    },
    refreshEvaluationResult(evalId, pid, key) {
      this.$http
        .get(`evaluate/${evalId}/${pid}`, {
          timeout: this.httpTimeoutEvaluation,
        })
        .then((response) => {
          this.evaluations[key].results[pid] = response.body;
          if (response.body.status === 'running') {
            setTimeout(() => {
              this.refreshEvaluationResult(evalId, pid, key);
            }, this.refreshTimeout);
          } else {
            const activeEvaluations = _.chain(this.evaluations)
              .toArray()
              .filter(ev => ev.id === evalId)
              .map(ev => ev.results)
              .map((res) => {
                const resCount = _.size(res);
                return _.chain(res)
                  .reduce((acc, val) => {
                    if (val.status === 'done') {
                      return acc - 1;
                    }
                    return acc;
                  }, resCount)
                  .value();
              })
              .first()
              .value();
            if (activeEvaluations === 0 && this.evaluations[key].input.type === 'file') {
              this.evaluations[key].comparisonText = 'Classifier comparison is now running.';
              this.$http
                .post(`evaluate/${evalId}/compare_classifiers`, {
                  timeout: this.httpTimeoutEvaluation,
                })
                .then((res) => {
                  this.$set(this.evaluationComparisons, evalId, res.body);
                })
                .catch(() => {
                  this.evaluationComparisons[evalId] = false;
                  this.evaluations[key].comparisonText = 'Classifier comparison failed.';
                })
                .then(() => {});
            }
          }
        });
    },
    checkAllProcesses() {
      this.processesChecked = _.mapValues(this.processesChecked, () => true);
    },
    uncheckAllProcesses() {
      this.processesChecked = _.mapValues(this.processesChecked, () => false);
    },
    checkBestProcess() {
      this.uncheckAllProcesses();
      this.processesChecked[this.bestProcess.job_proc] = true;
    },
    color(str) {
      return this.colorArrayRandom([str])[0].substr(1);
    },
  },
};
</script>
